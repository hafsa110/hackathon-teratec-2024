MODULE M_PROFIL_EVOLUTION
  USE M_PROFIL_UTILS
  USE M_PROFIL_SIMPLE
  !------------------------------
  IMPLICIT NONE
  PRIVATE ! set all to be private
  PUBLIC :: PROFIL_EVOLUTION, PROFIL_EVOLUTION_T
  !------------------------------
  TYPE PROFIL_EVOLUTION_T
     INTEGER :: OPT   ! option of evolution
     INTEGER :: NPROF, NPAS ! number of profiles and discretization steps
     REAL(DOUBLE), POINTER :: PAS(:)  ! space step of "planimetrage"
     TYPE(ARRAY_POINTER_T),  POINTER :: COORD(:)  ! initial coordinates
     TYPE(PROFIL_COURLIS_T), POINTER :: PROF_COURLIS(:) ! alias to profil courlis
     TYPE(PROFIL_PLAN_T),    POINTER :: PROF_INIT ! initial "planimetrage"
     TYPE(PROFIL_SIMPLE_T),  POINTER :: PROF_SIMP ! simple "planimetrage"
   CONTAINS
     PROCEDURE, PASS :: LECPARAM => LECPARAM_PROFIL_EVOLUTION
     PROCEDURE, PASS :: INIT     => INIT_PROFIL_EVOLUTION
     PROCEDURE, PASS :: FREE     => FREE_PROFIL_EVOLUTION
     PROCEDURE, PASS :: UPDATE   => UPDATE_PROFIL_EVOLUTION
     PROCEDURE, PASS :: PLANIM   => PLANIM_PROFIL_EVOLUTION
  END TYPE PROFIL_EVOLUTION_T
  !--------------------------------------------------------------
  TYPE(PROFIL_EVOLUTION_T) :: PROFIL_EVOLUTION ! shared object
  !--------------------------------------------------------------
CONTAINS
  !------------------------------------
  SUBROUTINE LECPARAM_PROFIL_EVOLUTION(PROF_EVOL, &
       ADRESS, MOTINT, MOTREA, MOTLOG, MOTCAR)
    CLASS(PROFIL_EVOLUTION_T), INTENT(INOUT) :: PROF_EVOL
    INTEGER, INTENT(IN)                      :: ADRESS(:,:)
    INTEGER, INTENT(IN)                      :: MOTINT(:)  ! TYPE 1
    LOGICAL, INTENT(IN)                      :: MOTLOG(:)  ! TYPE 2
    REAL(DOUBLE), INTENT(IN)                 :: MOTREA(:)  ! TYPE 3
    CHARACTER(LEN=144), INTENT(IN)           :: MOTCAR(:)  ! TYPE 4
    CHARACTER(255) :: FILE_LIMIT
    INTEGER :: MSG
    REAL(DOUBLE) :: LIMIT
    !------------------
    PROF_EVOL%OPT = MOTINT(ADRESS(1,842))
    WRITE(*,*) "-----------------------------------"
    WRITE(*,'(A,I3)') "  + OPTION FOR PROFILE EVOLUTION: ", PROF_EVOL%OPT
    SELECT CASE(PROF_EVOL%OPT)
    CASE(PROF_EVOL_UNIF)
    CASE(PROF_EVOL_SIMP)
       ALLOCATE(PROF_EVOL%PROF_SIMP, STAT = MSG)
       IF (MSG /= 0) STOP "ERROR: CAN NOT ALLOCATE PROF_EVOL%PROF_SIMP"

       FILE_LIMIT = MOTCAR(ADRESS(4,637))
       PROF_EVOL%PROF_SIMP%FILE_LIMIT = FILE_LIMIT
       IF (FILE_LIMIT .EQ. ' ') THEN
          LIMIT = MOTREA(ADRESS(2,34))
          PROF_EVOL%PROF_SIMP%LIMIT = LIMIT
          WRITE(*,'(A,F10.5)') "  + IMPOSED ELEVATION FOR EROSION: ", LIMIT
       ELSE
          WRITE(*,'(2A)') "  + FILE FOR IMPOSED ELEVATIONS FOR EROSION: ", TRIM(FILE_LIMIT)
       END IF
    END SELECT
    WRITE(*,*) "-----------------------------------"
  END SUBROUTINE LECPARAM_PROFIL_EVOLUTION
  !------------------------------------
  SUBROUTINE INIT_PROFIL_PLAN(NPROF, NPAS, PROF_INIT, PROF_PLAN)
    INTEGER, INTENT(IN) :: NPROF, NPAS
    TYPE(PROFIL_PLAN_T), INTENT(OUT) :: PROF_INIT ! the result
    TYPE(PROFIL_PLAN_T), INTENT(IN)  :: PROF_PLAN
    INTEGER :: MSG, IPROF, IPAS
    !---------------------
    ALLOCATE( &
         PROF_INIT%B1(NPROF, NPAS), &
         !PROF_INIT%B2(NPROF, NPAS), &
         PROF_INIT%P1(NPROF, NPAS), &
         !PROF_INIT%P2(NPROF, NPAS), &
         PROF_INIT%S1(NPROF, NPAS), &
         !PROF_INIT%S2(NPROF, NPAS), &
         STAT = MSG)
    IF(MSG /= 0) STOP "ERROR: CAN NOT ALLOCATE PROF_INIT%B1"
    ! 2- copy the initial "planimetrage"
    DO IPROF = 1, NPROF
       DO IPAS = 1, NPAS
          PROF_INIT%B1(IPROF, IPAS)  = PROF_PLAN%B1(IPROF, IPAS)
          !PROF_INIT%B2(IPROF, IPAS)  = PROF_PLAN%B2(IPROF, IPAS)
          PROF_INIT%P1(IPROF, IPAS)  = PROF_PLAN%P1(IPROF, IPAS)
          !PROF_INIT%P2(IPROF, IPAS)  = PROF_PLAN%P2(IPROF, IPAS)
          PROF_INIT%S1(IPROF, IPAS)  = PROF_PLAN%S1(IPROF, IPAS)
          !PROF_INIT%S2(IPROF, IPAS)  = PROF_PLAN%S2(IPROF, IPAS)
       END DO
    END DO

  END SUBROUTINE INIT_PROFIL_PLAN
  !------------------------------------
  SUBROUTINE FREE_PROFIL_PLAN(PROF_PLAN)
    TYPE(PROFIL_PLAN_T), INTENT(INOUT)  :: PROF_PLAN
    IF(ASSOCIATED(PROF_PLAN%B1)) DEALLOCATE(PROF_PLAN%B1)
    ! IF(ASSOCIATED(PROF_PLAN%B2)) DEALLOCATE(PROF_PLAN%B2)
    IF(ASSOCIATED(PROF_PLAN%P1)) DEALLOCATE(PROF_PLAN%P1)
    ! IF(ASSOCIATED(PROF_PLAN%P2)) DEALLOCATE(PROF_PLAN%P2)
    IF(ASSOCIATED(PROF_PLAN%S1)) DEALLOCATE(PROF_PLAN%S1)
    ! IF(ASSOCIATED(PROF_PLAN%S2)) DEALLOCATE(PROF_PLAN%S2)
  END SUBROUTINE FREE_PROFIL_PLAN
  !------------------------------------
  SUBROUTINE INIT_PROFIL_EVOLUTION(PROF_EVOL, &
       PROFIL, PROF_PLAN, PROF_COURLIS)
    CLASS(PROFIL_EVOLUTION_T), INTENT(INOUT)    :: PROF_EVOL
    TYPE(PROFIL_T), INTENT(IN)                  :: PROFIL(:)
    TYPE(PROFIL_COURLIS_T), POINTER, INTENT(IN) :: PROF_COURLIS(:)
    TYPE(PROFIL_PLAN_T), INTENT(IN)             :: PROF_PLAN
    INTEGER :: MSG, NPROF, IPROF, NPAS, NPOIN, IPOIN
    ! alias
    REAL(DOUBLE), POINTER          :: X(:), Z(:,:)
    REAL(DOUBLE), POINTER          :: PROF_PAS(:)
    TYPE(ARRAY_POINTER_T), POINTER :: PROF_COORD(:)
    TYPE(PROFIL_PLAN_T), POINTER   :: PROF_INIT
    TYPE(PROFIL_SIMPLE_T), POINTER :: PROF_SIMP
    !-------------------
    ! 1- dimensions
    NPROF = SIZE(PROFIL)
    NPAS  = PROFIL(1)%NBPAS
    ! save
    PROF_EVOL%NPROF = NPROF
    PROF_EVOL%NPAS  = NPAS
    ! 2- copy the initial profil
    ALLOCATE( &
         PROF_EVOL%PAS(NPROF), &
         PROF_EVOL%COORD(NPROF), &
         STAT=MSG)
    IF(MSG /= 0) STOP "ERROR INIT_PROFIL_EVOLUTION: CAN NOT ALLOCATE"
    PROF_COORD => PROF_EVOL%COORD
    DO IPROF = 1, NPROF
       PROF_EVOL%PAS(IPROF)  = PROFIL(IPROF)%PAS
       ! profil_courlis
       NPOIN = PROF_COURLIS(IPROF)%NBPOINT
       X => PROF_COURLIS(IPROF)%X
       Z => PROF_COURLIS(IPROF)%Z
       CALL ALLOC_ARRAY_POINTER(PROF_COORD(IPROF), &
            NPOIN, DIM2=2, RDATA=.TRUE.)
       DO IPOIN = 1, NPOIN
          PROF_COORD(IPROF)%R(IPOIN,1) = X(IPOIN)
          PROF_COORD(IPROF)%R(IPOIN,2) = Z(1, IPOIN) ! water/sed. interface
       END DO
    END DO
    ! alias to PROF_COURLIS (utile for debug, post-processing)
    PROF_EVOL%PROF_COURLIS => PROF_COURLIS
    ! 3- copy the initial planimetrage
    ALLOCATE(PROF_EVOL%PROF_INIT, STAT = MSG)
    IF (MSG /= 0) STOP "ERROR: CAN NOT ALLOCATE PROF_EVOL%PROF_INT"
    PROF_INIT => PROF_EVOL%PROF_INIT ! alias
    CALL INIT_PROFIL_PLAN(NPROF, NPAS, PROF_INIT, PROF_PLAN)
    ! 4- for each type of profil evolution
    SELECT CASE(PROF_EVOL%OPT)
    CASE(PROF_EVOL_UNIF)
    CASE(PROF_EVOL_SIMP)
       IF(.NOT. ASSOCIATED(PROF_EVOL%PROF_SIMP)) &
            STOP "ERROR: PROFIL_SIMPLE WAS NOT ALLOCATED"
       PROF_PAS  => PROF_EVOL%PAS
       PROF_SIMP => PROF_EVOL%PROF_SIMP ! alias
       CALL INIT_PROFIL_SIMPLE(NPROF, NPAS, PROF_SIMP, &
            PROF_PAS, PROF_COORD, PROF_INIT)
    END SELECT
  END SUBROUTINE INIT_PROFIL_EVOLUTION
  !------------------------------------
  SUBROUTINE FREE_PROFIL_EVOLUTION(PROF_EVOL)
    CLASS(PROFIL_EVOLUTION_T), INTENT(INOUT) :: PROF_EVOL
    INTEGER :: NPROF, IPROF
    !
    NULLIFY(PROF_EVOL%PROF_COURLIS) ! attention: DO NOT deallocate
    !
    DEALLOCATE(PROF_EVOL%PAS)
    IF(ASSOCIATED(PROF_EVOL%COORD)) THEN
       NPROF = PROF_EVOL%NPROF
       DO IPROF = 1, NPROF
          CALL FREE_ARRAY_POINTER(PROF_EVOL%COORD(IPROF))
       END DO
       DEALLOCATE(PROF_EVOL%COORD)
    END IF
    IF(ASSOCIATED(PROF_EVOL%PROF_INIT)) THEN
       CALL FREE_PROFIL_PLAN(PROF_EVOL%PROF_INIT)
       DEALLOCATE(PROF_EVOL%PROF_INIT)
    END IF
    IF(PROF_EVOL%OPT.EQ.PROF_EVOL_SIMP) THEN
       CALL FREE_PROFIL_SIMPLE(PROF_EVOL%PROF_SIMP)
       DEALLOCATE(PROF_EVOL%PROF_SIMP)
    END IF
  END SUBROUTINE FREE_PROFIL_EVOLUTION
  !------------------------------------
  SUBROUTINE UPDATE_PROFIL_EVOLUTION(PROF_EVOL, VSED)
    CLASS(PROFIL_EVOLUTION_T), INTENT(INOUT) :: PROF_EVOL
    REAL(DOUBLE), INTENT(IN)                 :: VSED(:)
    INTEGER :: NPROF, NPAS
    ! alias
    REAL(DOUBLE), POINTER           :: PROF_PAS(:)
    TYPE(ARRAY_POINTER_T), POINTER  :: PROF_COORD(:)
    TYPE(PROFIL_COURLIS_T), POINTER :: PROF_COURLIS(:)
    TYPE(PROFIL_PLAN_T), POINTER    :: PROF_INIT
    TYPE(PROFIL_SIMPLE_T), POINTER  :: PROF_SIMP
    ! create the alias
    NPROF = PROF_EVOL%NPROF
    NPAS  = PROF_EVOL%NPAS
    PROF_PAS   => PROF_EVOL%PAS
    PROF_COORD => PROF_EVOL%COORD
    PROF_COURLIS => PROF_EVOL%PROF_COURLIS
    PROF_INIT  => PROF_EVOL%PROF_INIT
    ! for each type of profil evolution
    SELECT CASE(PROF_EVOL%OPT)
    CASE(PROF_EVOL_UNIF)
    CASE(PROF_EVOL_SIMP)
       PROF_SIMP => PROF_EVOL%PROF_SIMP
       CALL UPDATE_PROFIL_SIMPLE(NPROF, NPAS, PROF_SIMP, &
            PROF_PAS, PROF_COORD, PROF_INIT, PROF_COURLIS, VSED)
    END SELECT
  END SUBROUTINE UPDATE_PROFIL_EVOLUTION
  !------------------------------------
  SUBROUTINE PLANIM_PROFIL_EVOLUTION(PROF_EVOL, IPROF, PROF_PLAN)
    CLASS(PROFIL_EVOLUTION_T), INTENT(INOUT) :: PROF_EVOL
    INTEGER, INTENT(IN)                      :: IPROF
    TYPE(PROFIL_PLAN_T), INTENT(INOUT)       :: PROF_PLAN
    ! alias
    REAL(DOUBLE), POINTER          :: PROF_PAS(:)
    TYPE(PROFIL_PLAN_T), POINTER   :: PROF_INIT
    TYPE(PROFIL_SIMPLE_T), POINTER :: PROF_SIMP
    INTEGER :: NPAS
    ! create the alias
    NPAS  = PROF_EVOL%NPAS
    PROF_PAS   => PROF_EVOL%PAS
    PROF_INIT  => PROF_EVOL%PROF_INIT
    ! for each type of profil evolution
    SELECT CASE(PROF_EVOL%OPT)
    CASE(PROF_EVOL_UNIF)
    CASE(PROF_EVOL_SIMP)
       PROF_SIMP => PROF_EVOL%PROF_SIMP
       CALL PLANIM_PROFIL_SIMPLE(IPROF, NPAS, PROF_SIMP, &
            PROF_PAS, PROF_INIT, PROF_PLAN)
    END SELECT
  END SUBROUTINE PLANIM_PROFIL_EVOLUTION
  !------------------------------------
END MODULE M_PROFIL_EVOLUTION
